```r
---
title: "Rosalind Bioinformatics Problems"
author: "Billy Trim"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```

# Rosalind Problems + Answers

Solutions to bioinformatics problems from [Rosalind](http://rosalind.info/), implemented in both Python and R.

---

## Python Village

### Problem 1: Variables and Arithmetic
**Problem:** Given two integers, return the square of the hypotenuse of a right triangle whose legs have lengths `a` and `b`.

```{python}
with open('Variables and Arithmetic (3).txt', 'r') as f:  # read file
    a, b = map(int, f.read().split()) 
result = a**2 + b**2
print(result)
    # f.read reads the entire file as string 
    # split splits the string by whitespace into list 
    # map converts string to int
```

---

### Problem 2: Strings and Lists
**Problem:** Slice out positions `a` to `b` and `c` to `d` from string `S`, then join slices with a space.

```{python}
S = "Psalmopoeusa3ezSG8BPFk9J70lJjACB3XN8kF7lg3PbCKFLcWdWYWW9gGOM0GPPX3Y1KAmEnlBwKaoSSAcateniferZEFpcJjKlQumJERNqQ1nIHKQosP2TXUYwoNZov0QZOxxnf4hIPxALmXZjFX3peOEQFcXghnFXTBRrKAzLHzq"
a, b, c, d = 0, 10, 82, 90
slice1 = S[a:b+1]  # +1 because python grabs from start - not including end
slice2 = S[c:d+1]
result = slice1 + " " + slice2
print(result)
```

**Reading from file:**

```{python}
with open('Rosalind Strings and Lists.txt', 'r') as file:
    S = file.readline().strip()
    numbers = file.readline().strip()
a, b, c, d = map(int, numbers.split())
slice1 = S[a:b+1]
slice2 = S[c:d+1]
result = slice1 + " " + slice2
print(result)
```

---

### Problem 3: Conditions and Loops
**Problem:** Given `a < b < 10,000`, return the sum of all odd integers from `a` to `b`, inclusively.

```{python}
odd = []
for i in range(4940, 9340+1):
    if i % 2 == 1:
        odd.append(i)  # adds to list (in loop)
print(sum(odd))
```

**Reading from file:**

```{python}
with open('Conditions and Loops (1).txt', 'r') as file:
    numbers = file.readline().strip()
    a, b = map(int, numbers.split())
    odd = []
    for i in range(a, b+1):
        if i % 2 == 1:
            odd.append(i)
print(sum(odd))
```

---

### Problem 4: Working with Files
**Problem:** Given a file containing < 1000 lines, output a file with all even-numbered lines.

```{python}
with open('Rosalind ini5.txt', 'r') as file:
    lines = file.readlines()
even_lines = []
for line_numb, line in enumerate(lines, start=1):
     if line_numb % 2 == 0:
        even_lines.append(line)
with open('output.txt', 'w') as file:
    file.writelines(even_lines)
```

---

### Problem 5: Dictionaries
**Problem:** Given a string `S` < 10,000 letters, return the number of occurrences of each word in `S`, where words are separated by spaces. Case sensitive.

```{python}
with open('Rosalind Dictionaries (1).txt', 'r') as file:
    S = file.readline().strip()
word_counts = {}
words = S.split(' ')

for word in words:
    word_counts[word] = word_counts.get(word, 0) + 1

for words, word in word_counts.items():
    print(words, word)
```

---

## Bioinformatics Stronghold

### Problem 1: Counting DNA Nucleotides
**Problem:** Given a DNA string, return four integers counting the respective base pairs (A, C, G, T).

**Python:**

```{python}
with open('Counting DNA Nucleotides (1).txt', 'r') as file:
    S = file.readline().strip()
bases = ('A', 'C', 'G', 'T')  # tuple
chr_count = {}  # set dictionary
for base in S: 
    chr_count[base] = chr_count.get(base, 0) + 1  # update dictionary
    # loops through counting bases: never = 0 & if we have seen it returns the counts + 1
counts = [chr_count.get(base, 0) for base in bases]  # list comprehension
# for each letter in the tuple, .get() counts how many times in the string
print(' '.join(str(count) for count in counts))  # join numbers in counts > string > separated by whitespace
```

**R:**

```{r}
txt_path <- "Counting DNA Nucleotides (1).txt"
S <- readLines(txt_path)
print(S)
bases <- strsplit(S, "")[[1]]
count <- table(bases)
print(count)
```

---

### Problem 2: Transcribing DNA into RNA
**Problem:** Given a DNA string `t` corresponding to a coding strand, its transcribed RNA string `u` is formed by replacing all occurrences of 'T' in `t` with 'U' in `u`. Return the transcribed RNA string of `t`.

**Python:**

```{python}
with open('Transcribing DNA to RNA.txt', 'r') as file:
    t = file.readline().strip()
transc = t.replace("T", "U")
print(transc)
```

**R:**

```{r}
txt <- "Transcribing DNA to RNA.txt"
t <- readLines(txt)
print(t)
transc <- gsub(pattern = "T", replacement = "U", x = t)
print(transc)
# or
transc <- chartr(old = "T", new = "U", x = t)
```

---

### Problem 3: Complementing a Strand of DNA
**Problem:** Given a DNA string, return the reverse complement of the string.

**Python:**

```{python}
import Bio 
from Bio.Seq import Seq
with open('DNA Complement Strand.txt', 'r') as file:
    s = file.readline().strip()
seq = Seq(s)
rev_comp = seq.reverse_complement()
print(str(rev_comp))
```

**R:**

```{r}
txt <- "DNA Complement Strand.txt"
s <- readLines(txt)[1]

rc <- function(x) {
  ss <- unlist(strsplit(x, NULL))
  ssrev <- rev(ss)
  
  for (i in seq_along(ssrev)) {
    if (ssrev[i] == "T") {
      ssrev[i] <- "A"
    } else if (ssrev[i] == "A") {
      ssrev[i] <- "T"
    } else if (ssrev[i] == "G") {
      ssrev[i] <- "C"
    } else if (ssrev[i] == "C") {
      ssrev[i] <- "G"
    }
  }
  
  sc <- paste(ssrev, collapse = "")
  return(sc)
}

rc_seq <- rc(s)
cat(rc_seq, "\n")
```

---

### Problem 4: Rabbits and Recurrence Relations
**Problem:** Given positive integers `n` and `k`, return the total number of rabbit pairs that will be present after `n` months, if we begin with 1 pair and in each generation, every pair of reproduction-age rabbits produces a litter of `k` rabbit pairs.

**R:**

```{r}
rabbit_pairs_month <- c()
n <- 28  # number of months
k <- 2   # each pair produces k new pairs per month

for(i in 1:n) {
    if(i == 1) {
        rabbit_pairs_month[i] <- 1  # month 1 = 1 pair
    } else if(i == 2) {
        rabbit_pairs_month[i] <- 1  # still 1 pair (not reproducing yet)
    } else {
        rabbit_pairs_month[i] <- rabbit_pairs_month[i-1] + k * rabbit_pairs_month[i-2]
    } 
    # rabbits > 2 months old produce k pairs
    # rpm(n-1) = pairs alive last month
    # rpm(n-2) = pairs old enough to reproduce, 2 months ago
}
rabbit_pairs_month[length(rabbit_pairs_month)]
```

**Python:**

```{python}
n, k = 28, 2

def mortal_r(n, k):
    if n == 1 or n == 2:
        return 1

    F_prev2 = 1  # f1
    F_prev1 = 1  # f2

    for _ in range(3, n + 1):
        F_curr = F_prev1 + k * F_prev2
        F_prev2, F_prev1 = F_prev1, F_curr

    return F_curr

print(mortal_r(n, k))
```

---
